<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš« ì˜¤ëª© ê²Œì„ - Claude AI</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        .game-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }
        .game-board {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .omok-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            gap: 1px;
            max-width: 600px;
            margin: 2rem auto;
            background: #8B4513;
            padding: 10px;
            border-radius: 10px;
        }
        .omok-cell {
            width: 35px;
            height: 35px;
            border: 1px solid #654321;
            background: #DEB887;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .omok-cell:hover {
            background: #F5DEB3;
            transform: scale(1.1);
        }
        .omok-cell.black {
            background: radial-gradient(circle, #000 60%, #333 100%);
            border-radius: 50%;
        }
        .omok-cell.white {
            background: radial-gradient(circle, #fff 60%, #ddd 100%);
            border-radius: 50%;
        }
        .omok-cell.winning {
            animation: winning-pulse 1s infinite;
        }
        @keyframes winning-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .btn-game {
            background: #667eea;
            color: white;
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0 0.5rem;
        }
        .game-status {
            text-align: center;
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .game-controls {
            text-align: center;
            margin: 1rem 0;
        }
        .difficulty-selector {
            margin: 1rem 0;
        }
        .difficulty-selector select {
            padding: 0.5rem;
            font-size: 1rem;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin: 0 0.5rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <h1 class="logo">âš« ì˜¤ëª© ê²Œì„</h1>
            <p class="subtitle">Claude AIì™€ í•¨ê»˜í•˜ëŠ” ì „ëµì  ì˜¤ëª©!</p>
        </div>
    </header>

    <main class="main">
        <div class="game-container">
            <div class="game-board">
                <h2>âš« ì˜¤ëª© (15x15)</h2>
                <p>15x15 ë³´ë“œì—ì„œ ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ ìœ¼ë¡œ 5ê°œë¥¼ ì—°ì†ìœ¼ë¡œ ë†“ìœ¼ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</p>
                
                <div class="game-status">
                    <h3>ê²Œì„ ê·œì¹™</h3>
                    <ul style="text-align: left; display: inline-block;">
                        <li>í”Œë ˆì´ì–´ëŠ” í‘ëŒ(âš«), AIëŠ” ë°±ëŒ(âšª)</li>
                        <li>ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ ìœ¼ë¡œ 5ê°œ ì—°ì† ë†“ê¸°</li>
                        <li>Claude AIê°€ ì „ëµì ìœ¼ë¡œ í”Œë ˆì´</li>
                    </ul>
                </div>
                
                <div class="difficulty-selector">
                    <label for="difficulty">ë‚œì´ë„:</label>
                    <select id="difficulty">
                        <option value="easy">ì‰¬ì›€</option>
                        <option value="normal">ë³´í†µ</option>
                        <option value="hard">ì–´ë ¤ì›€</option>
                        <option value="expert">ì „ë¬¸ê°€</option>
                    </select>
                </div>
                
                <div class="game-controls">
                    <button class="btn-game" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
                </div>
            </div>

            <div class="game-board" id="gameArea" style="display: none;">
                <h2>ê²Œì„ ì§„í–‰</h2>
                <div class="omok-board" id="omokBoard"></div>
                
                <div class="game-status" id="gameStatus">
                    <p>ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! í”Œë ˆì´ì–´ ì°¨ë¡€ì…ë‹ˆë‹¤.</p>
                </div>
                
                <div class="game-controls">
                    <button class="btn-game" onclick="endGame()">ê²Œì„ ì¢…ë£Œ</button>
                    <button class="btn-game" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
                </div>
            </div>

            <div class="game-board" id="gameOver" style="display: none;">
                <h2>ê²Œì„ ì¢…ë£Œ</h2>
                <div id="finalResult"></div>
                <button class="btn-game" onclick="restartGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 ê²Œì„ ì»¬ë ‰ì…˜. Django + Claude AIë¡œ êµ¬ì¶•ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
        </div>
    </footer>

    <script>
        let board = [];
        let currentPlayer = 'black';
        let gameActive = false;
        let difficulty = 'normal';
        const BOARD_SIZE = 15;

        function createBoard() {
            const boardElement = document.getElementById('omokBoard');
            boardElement.innerHTML = '';
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'omok-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.onclick = () => makeMove(i, j);
                    boardElement.appendChild(cell);
                }
            }
        }

        function startGame() {
            difficulty = document.getElementById('difficulty').value;
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(''));
            currentPlayer = 'black';
            gameActive = true;
            
            document.getElementById('gameArea').style.display = 'block';
            document.getElementById('gameStatus').innerHTML = '<p>ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! í”Œë ˆì´ì–´ ì°¨ë¡€ì…ë‹ˆë‹¤.</p>';
            
            createBoard();
        }

        function makeMove(row, col) {
            if (!gameActive || board[row][col] !== '' || currentPlayer !== 'black') {
                return;
            }
            
            // í”Œë ˆì´ì–´ ì´ë™
            board[row][col] = 'black';
            updateCell(row, col, 'black');
            
            if (checkWinner(row, col, 'black')) {
                endGame('player');
                return;
            }
            
            // AI ì°¨ë¡€
            currentPlayer = 'white';
            document.getElementById('gameStatus').innerHTML = '<p>AIê°€ ìƒê°í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>';
            
            setTimeout(aiMove, 1000);
        }

        function aiMove() {
            if (!gameActive) return;
            
            // AI ì „ëµ: ë‚œì´ë„ì— ë”°ë¥¸ ìˆ˜ì¤€
            let aiRow, aiCol;
            
            switch(difficulty) {
                case 'easy':
                    [aiRow, aiCol] = findRandomMove();
                    break;
                case 'normal':
                    [aiRow, aiCol] = findStrategicMove();
                    break;
                case 'hard':
                    [aiRow, aiCol] = findAdvancedMove();
                    break;
                case 'expert':
                    [aiRow, aiCol] = findExpertMove();
                    break;
                default:
                    [aiRow, aiCol] = findStrategicMove();
            }
            
            if (aiRow !== -1 && aiCol !== -1) {
                board[aiRow][aiCol] = 'white';
                updateCell(aiRow, aiCol, 'white');
                
                if (checkWinner(aiRow, aiCol, 'white')) {
                    endGame('ai');
                    return;
                }
            }
            
            // í”Œë ˆì´ì–´ ì°¨ë¡€
            currentPlayer = 'black';
            document.getElementById('gameStatus').innerHTML = '<p>í”Œë ˆì´ì–´ ì°¨ë¡€ì…ë‹ˆë‹¤.</p>';
        }

        function findRandomMove() {
            const emptyCells = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === '') {
                        emptyCells.push([i, j]);
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                return emptyCells[randomIndex];
            }
            return [-1, -1];
        }

        function findStrategicMove() {
            // ìŠ¹ë¦¬í•  ìˆ˜ ìˆëŠ” ìˆ˜ ì°¾ê¸°
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === '') {
                        board[i][j] = 'white';
                        if (checkWinner(i, j, 'white')) {
                            board[i][j] = '';
                            return [i, j];
                        }
                        board[i][j] = '';
                    }
                }
            }
            
            // í”Œë ˆì´ì–´ì˜ ìŠ¹ë¦¬ ìˆ˜ ë°©ì–´
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === '') {
                        board[i][j] = 'black';
                        if (checkWinner(i, j, 'black')) {
                            board[i][j] = '';
                            return [i, j];
                        }
                        board[i][j] = '';
                    }
                }
            }
            
            // ì¤‘ì•™ ê·¼ì²˜ ìš°ì„ 
            const center = Math.floor(BOARD_SIZE / 2);
            for (let i = center - 2; i <= center + 2; i++) {
                for (let j = center - 2; j <= center + 2; j++) {
                    if (i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE && board[i][j] === '') {
                        return [i, j];
                    }
                }
            }
            
            return findRandomMove();
        }

        function findAdvancedMove() {
            // ë” ê³ ê¸‰ ì „ëµ: 4ì—°ì† ë§Œë“¤ê¸°, 3ì—°ì† ë°©ì–´ ë“±
            let bestMove = findStrategicMove();
            if (bestMove[0] !== -1) return bestMove;
            
            // 3ì—°ì† ë§Œë“¤ê¸° ì‹œë„
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === '') {
                        if (countConsecutive(i, j, 'white') >= 3) {
                            return [i, j];
                        }
                    }
                }
            }
            
            return findRandomMove();
        }

        function findExpertMove() {
            // ìµœê³  ìˆ˜ì¤€ ì „ëµ: ë¯¸ë‹ˆë§¥ìŠ¤ ì•Œê³ ë¦¬ì¦˜ ë“±
            let bestMove = findAdvancedMove();
            if (bestMove[0] !== -1) return bestMove;
            
            // ë³´ë“œ ì „ì²´ ë¶„ì„
            let bestScore = -Infinity;
            let bestPosition = [-1, -1];
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === '') {
                        let score = evaluatePosition(i, j);
                        if (score > bestScore) {
                            bestScore = score;
                            bestPosition = [i, j];
                        }
                    }
                }
            }
            
            if (bestPosition[0] !== -1) {
                return bestPosition;
            }
            
            return findRandomMove();
        }

        function countConsecutive(row, col, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            let maxCount = 0;
            
            for (let [dr, dc] of directions) {
                let count = 1;
                
                // í•œ ë°©í–¥ìœ¼ë¡œ ì„¸ê¸°
                for (let step = 1; step < 5; step++) {
                    let r = row + dr * step;
                    let c = col + dc * step;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) {
                        break;
                    }
                    count++;
                }
                
                // ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì„¸ê¸°
                for (let step = 1; step < 5; step++) {
                    let r = row - dr * step;
                    let c = col - dc * step;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) {
                        break;
                    }
                    count++;
                }
                
                maxCount = Math.max(maxCount, count);
            }
            
            return maxCount;
        }

        function evaluatePosition(row, col) {
            let score = 0;
            
            // ì¤‘ì•™ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
            const center = Math.floor(BOARD_SIZE / 2);
            const distanceFromCenter = Math.abs(row - center) + Math.abs(col - center);
            score += (BOARD_SIZE - distanceFromCenter) * 2;
            
            // ì—°ì†ëœ ëŒ ê°œìˆ˜ì— ë”°ë¥¸ ì ìˆ˜
            const whiteCount = countConsecutive(row, col, 'white');
            const blackCount = countConsecutive(row, col, 'black');
            
            if (whiteCount >= 5) score += 10000;
            else if (whiteCount === 4) score += 1000;
            else if (whiteCount === 3) score += 100;
            else if (whiteCount === 2) score += 10;
            
            if (blackCount >= 5) score += 5000;
            else if (blackCount === 4) score += 500;
            else if (blackCount === 3) score += 50;
            else if (blackCount === 2) score += 5;
            
            return score;
        }

        function updateCell(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.className = `omok-cell ${player}`;
        }

        function checkWinner(row, col, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            
            for (let [dr, dc] of directions) {
                let count = 1;
                
                // í•œ ë°©í–¥ìœ¼ë¡œ ì„¸ê¸°
                for (let step = 1; step < 5; step++) {
                    let r = row + dr * step;
                    let c = col + dc * step;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) {
                        break;
                    }
                    count++;
                }
                
                // ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì„¸ê¸°
                for (let step = 1; step < 5; step++) {
                    let r = row - dr * step;
                    let c = col - dc * step;
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) {
                        break;
                    }
                    count++;
                }
                
                if (count >= 5) {
                    // ìŠ¹ë¦¬ ë¼ì¸ í•˜ì´ë¼ì´íŠ¸
                    highlightWinningLine(row, col, dr, dc);
                    return true;
                }
            }
            
            return false;
        }

        function highlightWinningLine(startRow, startCol, dr, dc) {
            for (let step = -2; step <= 2; step++) {
                let r = startRow + dr * step;
                let c = startCol + dc * step;
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    cell.classList.add('winning');
                }
            }
        }

        function endGame(winner) {
            gameActive = false;
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
            
            const finalResult = document.getElementById('finalResult');
            if (winner === 'player') {
                finalResult.innerHTML = '<h3>ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! AIë¥¼ ì´ê²¼ìŠµë‹ˆë‹¤!</h3>';
            } else if (winner === 'ai') {
                finalResult.innerHTML = '<h3>ğŸ˜” ì•„ì‰½ë„¤ìš”. AIê°€ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤.</h3>';
            }
        }

        function restartGame() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(''));
            currentPlayer = 'black';
            gameActive = false;
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameStatus').innerHTML = '<p>ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!</p>';
        }
    </script>
</body>
</html>
